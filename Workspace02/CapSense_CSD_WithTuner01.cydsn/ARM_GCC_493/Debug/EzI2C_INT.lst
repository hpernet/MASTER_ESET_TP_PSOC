ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"EzI2C_INT.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.EzI2C_ISR,"ax",%progbits
  19              		.align	2
  20              		.global	EzI2C_ISR
  21              		.thumb
  22              		.thumb_func
  23              		.type	EzI2C_ISR, %function
  24              	EzI2C_ISR:
  25              	.LFB0:
  26              		.file 1 ".\\Generated_Source\\PSoC5\\EzI2C_INT.c"
   1:.\Generated_Source\PSoC5/EzI2C_INT.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC5/EzI2C_INT.c **** * File Name: EzI2CINT.c
   3:.\Generated_Source\PSoC5/EzI2C_INT.c **** * Version 2.0
   4:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
   5:.\Generated_Source\PSoC5/EzI2C_INT.c **** * Description:
   6:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  This file contains the code that operates during the interrupt service
   7:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  routine.  For this component, most of the runtime code is located in
   8:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  the ISR.
   9:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  10:.\Generated_Source\PSoC5/EzI2C_INT.c **** *******************************************************************************
  11:.\Generated_Source\PSoC5/EzI2C_INT.c **** * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12:.\Generated_Source\PSoC5/EzI2C_INT.c **** * You may use this file only in accordance with the license, terms, conditions,
  13:.\Generated_Source\PSoC5/EzI2C_INT.c **** * disclaimers, and limitations in the end user license agreement accompanying
  14:.\Generated_Source\PSoC5/EzI2C_INT.c **** * the software package with which this file was provided.
  15:.\Generated_Source\PSoC5/EzI2C_INT.c **** *******************************************************************************/
  16:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
  17:.\Generated_Source\PSoC5/EzI2C_INT.c **** #include "EzI2C_PVT.h"
  18:.\Generated_Source\PSoC5/EzI2C_INT.c **** #include "cyapicallbacks.h"
  19:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
  20:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
  21:.\Generated_Source\PSoC5/EzI2C_INT.c **** /*******************************************************************************
  22:.\Generated_Source\PSoC5/EzI2C_INT.c **** * Function Name: EzI2C_ISR
  23:.\Generated_Source\PSoC5/EzI2C_INT.c **** ********************************************************************************
  24:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  25:.\Generated_Source\PSoC5/EzI2C_INT.c **** * Summary:
  26:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  Handle Interrupt Service Routine.
  27:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  28:.\Generated_Source\PSoC5/EzI2C_INT.c **** * Parameters:
  29:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  EzI2C_dataPtrS1 - The global variable which stores the pointer to the
  30:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  data exposed to an I2C master for the first slave address.
  31:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 2


  32:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  EzI2C_rwOffsetS1 - The global variable which stores an offset for read
  33:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  and write operations, is set at each write sequence of the first slave
  34:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  address.
  35:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  36:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  EzI2C_rwIndexS1: global variable, which stores pointer to the next
  37:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  value to be read or written for the first slave address.
  38:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  39:.\Generated_Source\PSoC5/EzI2C_INT.c **** * EzI2C_wrProtectS1 - The global variable which stores an offset where data
  40:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  is read only for the first slave address.
  41:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  42:.\Generated_Source\PSoC5/EzI2C_INT.c **** * EzI2C_bufSizeS1 - The global variable which stores the size of a data array
  43:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  exposed to the I2C master for the first slave address.
  44:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  45:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  EzI2C_dataPtrS2 - The global variable which stores a pointer to the
  46:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  data exposed to the I2C master for the second slave address.
  47:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  48:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  EzI2C_rwOffsetS2 - The global variable which stores an offset for read
  49:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  and write operations, is set at each write sequence of the second slave
  50:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  device.
  51:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  52:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  EzI2C_rwIndexS2 - The global variable which stores a pointer to the next
  53:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  value to be read or written for the second slave address.
  54:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  55:.\Generated_Source\PSoC5/EzI2C_INT.c **** * EzI2C_wrProtectS2 - The global variable which stores an offset where data
  56:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  is "Read only" for the second slave address.  ??
  57:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  58:.\Generated_Source\PSoC5/EzI2C_INT.c **** * EzI2C_bufSizeS2 - The global variable which stores the size of a data array
  59:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  exposed to the I2C master for the second slave address.
  60:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  61:.\Generated_Source\PSoC5/EzI2C_INT.c **** * EzI2C_curState - The global variable which stores a current state of an
  62:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  I2C state machine.
  63:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  64:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  EzI2C_curStatus - The global variable which stores the current status of
  65:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  the component.
  66:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  67:.\Generated_Source\PSoC5/EzI2C_INT.c **** * Return:
  68:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  EzI2C_rwOffsetS1 - The global variable which stores an offset for read
  69:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  and write operations, is set at each write sequence of the first slave
  70:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  address and is reset if a received slave address matches the first slave address
  71:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  and a next operation will be read.
  72:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  73:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  EzI2C_rwIndexS1 - The global variable which stores a pointer to the next
  74:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  value to be read or written for the first slave address. Is set to
  75:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  EzI2C_rwOffsetS1 and than incremented if a received slave address
  76:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  matches the first slave address and a next operation will be read.
  77:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  78:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  EzI2C_rwOffsetS2 - The global variable which stores an offset for read
  79:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  and write operations, is set at each write sequence of the second slave
  80:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  address. This variable changes if a new sub-address is passed to the slave.
  81:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  82:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  EzI2C_rwIndexS2 - The global variable which stores a pointer to the next
  83:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  value to be read or written for the second slave address. This variable
  84:.\Generated_Source\PSoC5/EzI2C_INT.c **** *  changes if a new sub-address is passed to the slave.
  85:.\Generated_Source\PSoC5/EzI2C_INT.c **** *
  86:.\Generated_Source\PSoC5/EzI2C_INT.c **** *******************************************************************************/
  87:.\Generated_Source\PSoC5/EzI2C_INT.c **** CY_ISR(EzI2C_ISR)
  88:.\Generated_Source\PSoC5/EzI2C_INT.c **** {
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 3


  27              		.loc 1 88 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 80B4     		push	{r7}
  33              		.cfi_def_cfa_offset 4
  34              		.cfi_offset 7, -4
  35 0002 00AF     		add	r7, sp, #0
  36              		.cfi_def_cfa_register 7
  89:.\Generated_Source\PSoC5/EzI2C_INT.c ****     static uint8  tmp8;
  90:.\Generated_Source\PSoC5/EzI2C_INT.c ****     static uint8  tmpCsr;
  91:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
  92:.\Generated_Source\PSoC5/EzI2C_INT.c **** #if (EzI2C_SUBADDR_WIDTH == EzI2C_SUBADDR_16BIT)
  93:.\Generated_Source\PSoC5/EzI2C_INT.c ****     static uint16 tmp16;
  94:.\Generated_Source\PSoC5/EzI2C_INT.c **** #endif /* (EzI2C_SUBADDR_WIDTH == EzI2C_SUBADDR_16BIT) */
  95:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
  96:.\Generated_Source\PSoC5/EzI2C_INT.c **** #ifdef EzI2C_ISR_ENTRY_CALLBACK
  97:.\Generated_Source\PSoC5/EzI2C_INT.c ****     EzI2C_ISR_EntryCallback();
  98:.\Generated_Source\PSoC5/EzI2C_INT.c **** #endif /* EzI2C_ISR_ENTRY_CALLBACK */
  99:.\Generated_Source\PSoC5/EzI2C_INT.c ****     
 100:.\Generated_Source\PSoC5/EzI2C_INT.c ****     /* Entry from interrupt
 101:.\Generated_Source\PSoC5/EzI2C_INT.c ****     *  In the hardware address compare mode, we can assume we only get interrupted
 102:.\Generated_Source\PSoC5/EzI2C_INT.c ****     *  when a valid address is recognized. In the software address compare mode,
 103:.\Generated_Source\PSoC5/EzI2C_INT.c ****     *  we have to check every address after a start condition.
 104:.\Generated_Source\PSoC5/EzI2C_INT.c ****     */
 105:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 106:.\Generated_Source\PSoC5/EzI2C_INT.c ****     /* Make copy to check Stop condition after bus has been released */
 107:.\Generated_Source\PSoC5/EzI2C_INT.c ****     tmpCsr = EzI2C_CSR_REG;
  37              		.loc 1 107 0
  38 0004 974B     		ldr	r3, .L22
  39 0006 1B78     		ldrb	r3, [r3]
  40 0008 DAB2     		uxtb	r2, r3
  41 000a 974B     		ldr	r3, .L22+4
  42 000c 1A70     		strb	r2, [r3]
 108:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 109:.\Generated_Source\PSoC5/EzI2C_INT.c ****     /* Check for address phase of the transaction */
 110:.\Generated_Source\PSoC5/EzI2C_INT.c ****     if (EzI2C_IS_BIT_SET(tmpCsr, EzI2C_CSR_ADDRESS))
  43              		.loc 1 110 0
  44 000e 964B     		ldr	r3, .L22+4
  45 0010 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  46 0012 03F00803 		and	r3, r3, #8
  47 0016 002B     		cmp	r3, #0
  48 0018 42D0     		beq	.L2
 111:.\Generated_Source\PSoC5/EzI2C_INT.c ****     {
 112:.\Generated_Source\PSoC5/EzI2C_INT.c ****         #if (EzI2C_ADDRESSES == EzI2C_TWO_ADDRESSES)
 113:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 114:.\Generated_Source\PSoC5/EzI2C_INT.c ****             /* Get slave address from data register */
 115:.\Generated_Source\PSoC5/EzI2C_INT.c ****             tmp8 = ((EzI2C_DATA_REG >> EzI2C_ADDRESS_SHIFT) & EzI2C_SADDR_MASK);
 116:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 117:.\Generated_Source\PSoC5/EzI2C_INT.c ****             if (tmp8 == EzI2C_addrS1)   /* Check for address 1  */
 118:.\Generated_Source\PSoC5/EzI2C_INT.c ****             {
 119:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 if (EzI2C_IS_BIT_SET(EzI2C_DATA_REG, EzI2C_READ_FLAG))
 120:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 {  /* Prepare next read op, get data and place in register */
 121:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 122:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Load first data byte  */
 123:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_DATA_REG = EzI2C_dataPtrS1[EzI2C_rwOffsetS1];
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 4


 124:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 125:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* ACK and transmit */
 126:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_CSR_REG = (EzI2C_CSR_ACK | EzI2C_CSR_TRANSMIT);
 127:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 128:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Set index to offset */
 129:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_rwIndexS1 = EzI2C_rwOffsetS1;
 130:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 131:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Advance to data location */
 132:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     ++EzI2C_rwIndexS1;
 133:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 134:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Set Read busy status */
 135:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_curStatus |= EzI2C_STATUS_RD1BUSY;
 136:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 137:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Prepare for read transaction */
 138:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_curState = EzI2C_SM_DEV1_RD_DATA;
 139:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 }
 140:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 else  /* Start of a Write transaction, reset pointers, first byte is address */
 141:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 {  /* Prepare next operation to write offset */
 142:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 143:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* ACK and ready to receive sub address */
 144:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_CSR_REG = EzI2C_CSR_ACK;
 145:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 146:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Set Write busy status */
 147:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_curStatus |= EzI2C_STATUS_WR1BUSY;
 148:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 149:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Prepare for read transaction */
 150:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_curState = EzI2C_SM_DEV1_WR_ADDR;
 151:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 152:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Stop Interrupt Enable */
 153:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_CFG_REG  |= EzI2C_CFG_STOP_IE;
 154:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 155:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 }  /* Prepared for next Write transaction */
 156:.\Generated_Source\PSoC5/EzI2C_INT.c ****             }   /* Slave address #1 is processed */
 157:.\Generated_Source\PSoC5/EzI2C_INT.c ****             else if (tmp8 == EzI2C_addrS2)   /* Check for address 2  */
 158:.\Generated_Source\PSoC5/EzI2C_INT.c ****             {
 159:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 if (EzI2C_IS_BIT_SET(EzI2C_DATA_REG, EzI2C_READ_FLAG))
 160:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 {  /* Prepare next read op, get data and place in register */
 161:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 162:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Load first data byte  */
 163:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_DATA_REG = EzI2C_dataPtrS2[EzI2C_rwOffsetS2];
 164:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 165:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* ACK and transmit */
 166:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_CSR_REG = (EzI2C_CSR_ACK | EzI2C_CSR_TRANSMIT);
 167:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 168:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Reset pointer to previous offset */
 169:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_rwIndexS2 = EzI2C_rwOffsetS2;
 170:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 171:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Advance to data location */
 172:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     ++EzI2C_rwIndexS2;
 173:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 174:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Set read busy status */
 175:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_curStatus |= EzI2C_STATUS_RD2BUSY;
 176:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 177:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Prepare for read transaction */
 178:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_curState = EzI2C_SM_DEV2_RD_DATA;
 179:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 180:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 }  /* Prepared for next Read transaction */
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 5


 181:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 else  /* Start of write transfer, reset ptrs, 1st byte is address */
 182:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 {  /* Prepare next operation to write offset */
 183:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 184:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* ACK and ready to receive address */
 185:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_CSR_REG = EzI2C_CSR_ACK;
 186:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 187:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Set Write busy status */
 188:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_curStatus |= EzI2C_STATUS_WR2BUSY;
 189:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 190:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Prepare for read transaction */
 191:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_curState = EzI2C_SM_DEV2_WR_ADDR;
 192:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 193:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Enable interrupt on Stop */
 194:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_CFG_REG  |= EzI2C_CFG_STOP_IE;
 195:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 } /* Prepared for the next Write transaction */
 196:.\Generated_Source\PSoC5/EzI2C_INT.c ****             }
 197:.\Generated_Source\PSoC5/EzI2C_INT.c ****             else   /* No address match */
 198:.\Generated_Source\PSoC5/EzI2C_INT.c ****             {   /* NAK address Match  */
 199:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_CSR_REG = EzI2C_CSR_NAK;
 200:.\Generated_Source\PSoC5/EzI2C_INT.c ****             }
 201:.\Generated_Source\PSoC5/EzI2C_INT.c ****         #else /* One slave address - hardware address matching */
 202:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 203:.\Generated_Source\PSoC5/EzI2C_INT.c ****             if (EzI2C_IS_BIT_SET(EzI2C_DATA_REG, EzI2C_READ_FLAG))
  49              		.loc 1 203 0
  50 001a 944B     		ldr	r3, .L22+8
  51 001c 1B78     		ldrb	r3, [r3]
  52 001e DBB2     		uxtb	r3, r3
  53 0020 03F00103 		and	r3, r3, #1
  54 0024 002B     		cmp	r3, #0
  55 0026 24D0     		beq	.L3
 204:.\Generated_Source\PSoC5/EzI2C_INT.c ****             {   /* Prepare next read op, get data and place in register */
 205:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 206:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Load first data byte  */
 207:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_DATA_REG = EzI2C_dataPtrS1[EzI2C_rwOffsetS1];
  56              		.loc 1 207 0
  57 0028 904A     		ldr	r2, .L22+8
  58 002a 914B     		ldr	r3, .L22+12
  59 002c 1B68     		ldr	r3, [r3]
  60 002e 9149     		ldr	r1, .L22+16
  61 0030 0988     		ldrh	r1, [r1]	@ movhi
  62 0032 89B2     		uxth	r1, r1
  63 0034 0B44     		add	r3, r3, r1
  64 0036 1B78     		ldrb	r3, [r3]
  65 0038 DBB2     		uxtb	r3, r3
  66 003a 1370     		strb	r3, [r2]
 208:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 209:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* ACK and transmit */
 210:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_CSR_REG = (EzI2C_CSR_ACK | EzI2C_CSR_TRANSMIT);
  67              		.loc 1 210 0
  68 003c 894B     		ldr	r3, .L22
  69 003e 1422     		movs	r2, #20
  70 0040 1A70     		strb	r2, [r3]
 211:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 212:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Reset pointer to previous offset */
 213:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_rwIndexS1 = EzI2C_rwOffsetS1;
  71              		.loc 1 213 0
  72 0042 8C4B     		ldr	r3, .L22+16
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 6


  73 0044 1B88     		ldrh	r3, [r3]	@ movhi
  74 0046 9AB2     		uxth	r2, r3
  75 0048 8B4B     		ldr	r3, .L22+20
  76 004a 1A80     		strh	r2, [r3]	@ movhi
 214:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 215:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Advance to data location */
 216:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 ++EzI2C_rwIndexS1;
  77              		.loc 1 216 0
  78 004c 8A4B     		ldr	r3, .L22+20
  79 004e 1B88     		ldrh	r3, [r3]	@ movhi
  80 0050 9BB2     		uxth	r3, r3
  81 0052 0133     		adds	r3, r3, #1
  82 0054 9AB2     		uxth	r2, r3
  83 0056 884B     		ldr	r3, .L22+20
  84 0058 1A80     		strh	r2, [r3]	@ movhi
 217:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 218:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Set read busy status */
 219:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_curStatus |= EzI2C_STATUS_RD1BUSY;
  85              		.loc 1 219 0
  86 005a 884B     		ldr	r3, .L22+24
  87 005c 1B78     		ldrb	r3, [r3]
  88 005e DBB2     		uxtb	r3, r3
  89 0060 43F01103 		orr	r3, r3, #17
  90 0064 DAB2     		uxtb	r2, r3
  91 0066 854B     		ldr	r3, .L22+24
  92 0068 1A70     		strb	r2, [r3]
 220:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 221:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Prepare for read transaction */
 222:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_curState = EzI2C_SM_DEV1_RD_DATA;
  93              		.loc 1 222 0
  94 006a 854B     		ldr	r3, .L22+28
  95 006c 0822     		movs	r2, #8
  96 006e 1A70     		strb	r2, [r3]
  97 0070 D9E0     		b	.L5
  98              	.L3:
 223:.\Generated_Source\PSoC5/EzI2C_INT.c ****             }
 224:.\Generated_Source\PSoC5/EzI2C_INT.c ****             else  /* Start of write transfer, reset ptrs, 1st byte is address */
 225:.\Generated_Source\PSoC5/EzI2C_INT.c ****             {   /* Prepare next operation to write offset */
 226:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 227:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* ACK and ready to receive address */
 228:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_CSR_REG = EzI2C_CSR_ACK;
  99              		.loc 1 228 0
 100 0072 7C4B     		ldr	r3, .L22
 101 0074 1022     		movs	r2, #16
 102 0076 1A70     		strb	r2, [r3]
 229:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 230:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Set Write activity */
 231:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_curStatus |= EzI2C_STATUS_WR1BUSY;
 103              		.loc 1 231 0
 104 0078 804B     		ldr	r3, .L22+24
 105 007a 1B78     		ldrb	r3, [r3]
 106 007c DBB2     		uxtb	r3, r3
 107 007e 43F01203 		orr	r3, r3, #18
 108 0082 DAB2     		uxtb	r2, r3
 109 0084 7D4B     		ldr	r3, .L22+24
 110 0086 1A70     		strb	r2, [r3]
 232:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 7


 233:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Prepare for read transaction */
 234:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_curState = EzI2C_SM_DEV1_WR_ADDR;
 111              		.loc 1 234 0
 112 0088 7D4B     		ldr	r3, .L22+28
 113 008a 0122     		movs	r2, #1
 114 008c 1A70     		strb	r2, [r3]
 235:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 236:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Enable interrupt on stop */
 237:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_CFG_REG |= EzI2C_CFG_STOP_IE;
 115              		.loc 1 237 0
 116 008e 7D4A     		ldr	r2, .L22+32
 117 0090 7C4B     		ldr	r3, .L22+32
 118 0092 1B78     		ldrb	r3, [r3]
 119 0094 DBB2     		uxtb	r3, r3
 120 0096 43F01003 		orr	r3, r3, #16
 121 009a DBB2     		uxtb	r3, r3
 122 009c 1370     		strb	r3, [r2]
 123 009e C2E0     		b	.L5
 124              	.L2:
 238:.\Generated_Source\PSoC5/EzI2C_INT.c ****             }
 239:.\Generated_Source\PSoC5/EzI2C_INT.c ****         #endif  /* (EzI2C_ADDRESSES == EzI2C_TWO_ADDRESSES) */
 240:.\Generated_Source\PSoC5/EzI2C_INT.c ****     }
 241:.\Generated_Source\PSoC5/EzI2C_INT.c ****     else if (EzI2C_IS_BIT_SET(tmpCsr, EzI2C_CSR_BYTE_COMPLETE))
 125              		.loc 1 241 0
 126 00a0 714B     		ldr	r3, .L22+4
 127 00a2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 128 00a4 03F00103 		and	r3, r3, #1
 129 00a8 002B     		cmp	r3, #0
 130 00aa 00F0BC80 		beq	.L5
 242:.\Generated_Source\PSoC5/EzI2C_INT.c ****     {   /* Check for data transfer */
 243:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 244:.\Generated_Source\PSoC5/EzI2C_INT.c ****         /* Data transfer state machine */
 245:.\Generated_Source\PSoC5/EzI2C_INT.c ****         switch (EzI2C_curState)
 131              		.loc 1 245 0
 132 00ae 744B     		ldr	r3, .L22+28
 133 00b0 1B78     		ldrb	r3, [r3]
 134 00b2 DBB2     		uxtb	r3, r3
 135 00b4 013B     		subs	r3, r3, #1
 136 00b6 072B     		cmp	r3, #7
 137 00b8 00F2A880 		bhi	.L6
 138 00bc 01A2     		adr	r2, .L8
 139 00be 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 140 00c2 00BF     		.p2align 2
 141              	.L8:
 142 00c4 E5000000 		.word	.L7+1
 143 00c8 FF000000 		.word	.L9+1
 144 00cc 0D020000 		.word	.L6+1
 145 00d0 4B010000 		.word	.L10+1
 146 00d4 0D020000 		.word	.L6+1
 147 00d8 0D020000 		.word	.L6+1
 148 00dc 0D020000 		.word	.L6+1
 149 00e0 95010000 		.word	.L11+1
 150              		.p2align 1
 151              	.L7:
 246:.\Generated_Source\PSoC5/EzI2C_INT.c ****         {
 247:.\Generated_Source\PSoC5/EzI2C_INT.c ****             /* Address written from Master to Slave. */
 248:.\Generated_Source\PSoC5/EzI2C_INT.c ****             case EzI2C_SM_DEV1_WR_ADDR:
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 8


 249:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 250:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* If 8-bit interface, Advance to WR_Data, else to ADDR2 */
 251:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 #if (EzI2C_SUBADDR_WIDTH == EzI2C_SUBADDR_8BIT)
 252:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     tmp8 = EzI2C_DATA_REG;
 253:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     if (tmp8 < EzI2C_bufSizeS1)
 254:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     {
 255:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* ACK and ready to receive data */
 256:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_CSR_REG = EzI2C_CSR_ACK;
 257:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 258:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Set offset to new value */
 259:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_rwOffsetS1 = tmp8;
 260:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 261:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Reset index to offset value */
 262:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_rwIndexS1 = tmp8;
 263:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 264:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Prepare for write transaction */
 265:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_curState = EzI2C_SM_DEV1_WR_DATA;
 266:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     }
 267:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     else    /* Out of range, NAK data and don't set offset */
 268:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     {
 269:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* NAK master */
 270:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_CSR_REG = EzI2C_CSR_NAK;
 271:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     }
 272:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 273:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 #else   /* 16-bit */
 274:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Save MSB of address */
 275:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     tmp16 = EzI2C_DATA_REG;
 152              		.loc 1 275 0
 153 00e4 614B     		ldr	r3, .L22+8
 154 00e6 1B78     		ldrb	r3, [r3]
 155 00e8 DBB2     		uxtb	r3, r3
 156 00ea 9AB2     		uxth	r2, r3
 157 00ec 664B     		ldr	r3, .L22+36
 158 00ee 1A80     		strh	r2, [r3]	@ movhi
 276:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 277:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* ACK and ready to receive address */
 278:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_CSR_REG = EzI2C_CSR_ACK;
 159              		.loc 1 278 0
 160 00f0 5C4B     		ldr	r3, .L22
 161 00f2 1022     		movs	r2, #16
 162 00f4 1A70     		strb	r2, [r3]
 279:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 280:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Prepare to get LSB of address */
 281:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_curState = EzI2C_SM_DEV1_WR_ADDR_LSB;
 163              		.loc 1 281 0
 164 00f6 624B     		ldr	r3, .L22+28
 165 00f8 0222     		movs	r2, #2
 166 00fa 1A70     		strb	r2, [r3]
 282:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 283:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 #endif  /* (EzI2C_SUBADDR_WIDTH == EzI2C_SUBADDR_8BIT) */
 284:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 285:.\Generated_Source\PSoC5/EzI2C_INT.c ****             break;  /* case EzI2C_SM_DEV1_WR_ADDR */
 167              		.loc 1 285 0
 168 00fc 93E0     		b	.L12
 169              	.L9:
 286:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 287:.\Generated_Source\PSoC5/EzI2C_INT.c ****             #if (EzI2C_SUBADDR_WIDTH == EzI2C_SUBADDR_16BIT)
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 9


 288:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 289:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Only used with 16-bit interface */
 290:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 case EzI2C_SM_DEV1_WR_ADDR_LSB:
 291:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 292:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Create offset */
 293:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     tmp16 = (uint16) (tmp16 << EzI2C_ADDRESS_LSB_SHIFT) | EzI2C_DATA_REG;
 170              		.loc 1 293 0
 171 00fe 624B     		ldr	r3, .L22+36
 172 0100 1B88     		ldrh	r3, [r3]
 173 0102 1B02     		lsls	r3, r3, #8
 174 0104 9AB2     		uxth	r2, r3
 175 0106 594B     		ldr	r3, .L22+8
 176 0108 1B78     		ldrb	r3, [r3]
 177 010a DBB2     		uxtb	r3, r3
 178 010c 9BB2     		uxth	r3, r3
 179 010e 1343     		orrs	r3, r3, r2
 180 0110 9AB2     		uxth	r2, r3
 181 0112 5D4B     		ldr	r3, .L22+36
 182 0114 1A80     		strh	r2, [r3]	@ movhi
 294:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 295:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Check range */
 296:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     if(tmp16 < EzI2C_bufSizeS1)
 183              		.loc 1 296 0
 184 0116 5C4B     		ldr	r3, .L22+36
 185 0118 1A88     		ldrh	r2, [r3]
 186 011a 5C4B     		ldr	r3, .L22+40
 187 011c 1B88     		ldrh	r3, [r3]	@ movhi
 188 011e 9BB2     		uxth	r3, r3
 189 0120 9A42     		cmp	r2, r3
 190 0122 0ED2     		bcs	.L13
 297:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     {
 298:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* ACK and ready to receive address */
 299:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_CSR_REG = EzI2C_CSR_ACK;
 191              		.loc 1 299 0
 192 0124 4F4B     		ldr	r3, .L22
 193 0126 1022     		movs	r2, #16
 194 0128 1A70     		strb	r2, [r3]
 300:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 301:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Set offset to new value */
 302:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_rwOffsetS1 = tmp16;
 195              		.loc 1 302 0
 196 012a 574B     		ldr	r3, .L22+36
 197 012c 1A88     		ldrh	r2, [r3]
 198 012e 514B     		ldr	r3, .L22+16
 199 0130 1A80     		strh	r2, [r3]	@ movhi
 303:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 304:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Reset index to offset value */
 305:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_rwIndexS1 = tmp16;
 200              		.loc 1 305 0
 201 0132 554B     		ldr	r3, .L22+36
 202 0134 1A88     		ldrh	r2, [r3]
 203 0136 504B     		ldr	r3, .L22+20
 204 0138 1A80     		strh	r2, [r3]	@ movhi
 306:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 307:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Prepare for write transaction */
 308:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_curState = EzI2C_SM_DEV1_WR_DATA;
 205              		.loc 1 308 0
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 10


 206 013a 514B     		ldr	r3, .L22+28
 207 013c 0422     		movs	r2, #4
 208 013e 1A70     		strb	r2, [r3]
 309:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     }
 310:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     else    /* Out of range, NAK data and don't set offset */
 311:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     {
 312:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* NAK master */
 313:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_CSR_REG = EzI2C_CSR_NAK;
 314:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     }
 315:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 break; /* case EzI2C_SM_DEV1_WR_ADDR_LSB */
 209              		.loc 1 315 0
 210 0140 71E0     		b	.L12
 211              	.L13:
 313:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     }
 212              		.loc 1 313 0
 213 0142 484B     		ldr	r3, .L22
 214 0144 0022     		movs	r2, #0
 215 0146 1A70     		strb	r2, [r3]
 216              		.loc 1 315 0
 217 0148 6DE0     		b	.L12
 218              	.L10:
 316:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 317:.\Generated_Source\PSoC5/EzI2C_INT.c ****             #endif  /* (EzI2C_SUBADDR_WIDTH == EzI2C_SUBADDR_16BIT) */
 318:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 319:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 320:.\Generated_Source\PSoC5/EzI2C_INT.c ****             /* Data written from master to slave. */
 321:.\Generated_Source\PSoC5/EzI2C_INT.c ****             case EzI2C_SM_DEV1_WR_DATA:
 322:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 323:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Check for valid range */
 324:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 if (EzI2C_rwIndexS1 < EzI2C_wrProtectS1)
 219              		.loc 1 324 0
 220 014a 4B4B     		ldr	r3, .L22+20
 221 014c 1B88     		ldrh	r3, [r3]	@ movhi
 222 014e 9AB2     		uxth	r2, r3
 223 0150 4F4B     		ldr	r3, .L22+44
 224 0152 1B88     		ldrh	r3, [r3]	@ movhi
 225 0154 9BB2     		uxth	r3, r3
 226 0156 9A42     		cmp	r2, r3
 227 0158 18D2     		bcs	.L15
 325:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 {
 326:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Get data, to ACK quickly */
 327:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     tmp8 = EzI2C_DATA_REG;
 228              		.loc 1 327 0
 229 015a 444B     		ldr	r3, .L22+8
 230 015c 1B78     		ldrb	r3, [r3]
 231 015e DAB2     		uxtb	r2, r3
 232 0160 4C4B     		ldr	r3, .L22+48
 233 0162 1A70     		strb	r2, [r3]
 328:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 329:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* ACK and ready to receive sub address */
 330:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_CSR_REG = EzI2C_CSR_ACK;
 234              		.loc 1 330 0
 235 0164 3F4B     		ldr	r3, .L22
 236 0166 1022     		movs	r2, #16
 237 0168 1A70     		strb	r2, [r3]
 331:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 332:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Write data to array */
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 11


 333:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_dataPtrS1[EzI2C_rwIndexS1] = tmp8;
 238              		.loc 1 333 0
 239 016a 414B     		ldr	r3, .L22+12
 240 016c 1B68     		ldr	r3, [r3]
 241 016e 424A     		ldr	r2, .L22+20
 242 0170 1288     		ldrh	r2, [r2]	@ movhi
 243 0172 92B2     		uxth	r2, r2
 244 0174 1344     		add	r3, r3, r2
 245 0176 474A     		ldr	r2, .L22+48
 246 0178 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 247 017a 1A70     		strb	r2, [r3]
 334:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 335:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Increment pointer */
 336:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_rwIndexS1++;
 248              		.loc 1 336 0
 249 017c 3E4B     		ldr	r3, .L22+20
 250 017e 1B88     		ldrh	r3, [r3]	@ movhi
 251 0180 9BB2     		uxth	r3, r3
 252 0182 0133     		adds	r3, r3, #1
 253 0184 9AB2     		uxth	r2, r3
 254 0186 3C4B     		ldr	r3, .L22+20
 255 0188 1A80     		strh	r2, [r3]	@ movhi
 337:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 }
 338:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 else
 339:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 {
 340:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* NAK cause beyond write area */
 341:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_CSR_REG = EzI2C_CSR_NAK;
 342:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 }
 343:.\Generated_Source\PSoC5/EzI2C_INT.c ****             break;  /* EzI2C_SM_DEV1_WR_DATA */
 256              		.loc 1 343 0
 257 018a 4CE0     		b	.L12
 258              	.L15:
 341:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 }
 259              		.loc 1 341 0
 260 018c 354B     		ldr	r3, .L22
 261 018e 0022     		movs	r2, #0
 262 0190 1A70     		strb	r2, [r3]
 263              		.loc 1 343 0
 264 0192 48E0     		b	.L12
 265              	.L11:
 344:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 345:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 346:.\Generated_Source\PSoC5/EzI2C_INT.c ****             /* Data read by master from slave */
 347:.\Generated_Source\PSoC5/EzI2C_INT.c ****             case EzI2C_SM_DEV1_RD_DATA:
 348:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 349:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Check ACK/NAK */
 350:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 if ((tmpCsr & EzI2C_CSR_LRB) == EzI2C_CSR_LRB_ACK)
 266              		.loc 1 350 0
 267 0194 344B     		ldr	r3, .L22+4
 268 0196 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 269 0198 03F00203 		and	r3, r3, #2
 270 019c 002B     		cmp	r3, #0
 271 019e 23D1     		bne	.L17
 351:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 {
 352:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Check for valid range */
 353:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     if (EzI2C_rwIndexS1 < EzI2C_bufSizeS1)
 272              		.loc 1 353 0
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 12


 273 01a0 354B     		ldr	r3, .L22+20
 274 01a2 1B88     		ldrh	r3, [r3]	@ movhi
 275 01a4 9AB2     		uxth	r2, r3
 276 01a6 394B     		ldr	r3, .L22+40
 277 01a8 1B88     		ldrh	r3, [r3]	@ movhi
 278 01aa 9BB2     		uxth	r3, r3
 279 01ac 9A42     		cmp	r2, r3
 280 01ae 14D2     		bcs	.L18
 354:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     {
 355:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Get data from array */
 356:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_DATA_REG = EzI2C_dataPtrS1[EzI2C_rwIndexS1];
 281              		.loc 1 356 0
 282 01b0 2E4A     		ldr	r2, .L22+8
 283 01b2 2F4B     		ldr	r3, .L22+12
 284 01b4 1B68     		ldr	r3, [r3]
 285 01b6 3049     		ldr	r1, .L22+20
 286 01b8 0988     		ldrh	r1, [r1]	@ movhi
 287 01ba 89B2     		uxth	r1, r1
 288 01bc 0B44     		add	r3, r3, r1
 289 01be 1B78     		ldrb	r3, [r3]
 290 01c0 DBB2     		uxtb	r3, r3
 291 01c2 1370     		strb	r3, [r2]
 357:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 358:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Send Data */
 359:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_CSR_REG = EzI2C_CSR_TRANSMIT;
 292              		.loc 1 359 0
 293 01c4 274B     		ldr	r3, .L22
 294 01c6 0422     		movs	r2, #4
 295 01c8 1A70     		strb	r2, [r3]
 360:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 361:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Increment pointer */
 362:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         ++EzI2C_rwIndexS1;
 296              		.loc 1 362 0
 297 01ca 2B4B     		ldr	r3, .L22+20
 298 01cc 1B88     		ldrh	r3, [r3]	@ movhi
 299 01ce 9BB2     		uxth	r3, r3
 300 01d0 0133     		adds	r3, r3, #1
 301 01d2 9AB2     		uxth	r2, r3
 302 01d4 284B     		ldr	r3, .L22+20
 303 01d6 1A80     		strh	r2, [r3]	@ movhi
 363:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     }
 364:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     else    /* No valid range */
 365:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     {
 366:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Out of range send FFs */
 367:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_DATA_REG = EzI2C_DUMMY_DATA;
 368:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 369:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Send Data */
 370:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_CSR_REG = EzI2C_CSR_TRANSMIT;
 371:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     }
 372:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 }
 373:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 else    /* Data was NAKed */
 374:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 {
 375:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Send dummy data at the end of read transaction */
 376:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_DATA_REG = EzI2C_DUMMY_DATA;
 377:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 378:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Clear transmit bit at the end of read transaction */
 379:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_CSR_REG = EzI2C_CSR_NAK;
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 13


 380:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 381:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Clear Busy Flag */
 382:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_curStatus &= ((uint8) ~EzI2C_STATUS_BUSY);
 383:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 384:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Error or Stop, reset state */
 385:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     EzI2C_curState = EzI2C_SM_IDLE;
 386:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 387:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 }
 388:.\Generated_Source\PSoC5/EzI2C_INT.c ****             break;  /* EzI2C_SM_DEV1_RD_DATA */
 304              		.loc 1 388 0
 305 01d8 25E0     		b	.L12
 306              	.L18:
 367:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 307              		.loc 1 367 0
 308 01da 244B     		ldr	r3, .L22+8
 309 01dc FF22     		movs	r2, #255
 310 01de 1A70     		strb	r2, [r3]
 370:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     }
 311              		.loc 1 370 0
 312 01e0 204B     		ldr	r3, .L22
 313 01e2 0422     		movs	r2, #4
 314 01e4 1A70     		strb	r2, [r3]
 315              		.loc 1 388 0
 316 01e6 1EE0     		b	.L12
 317              	.L17:
 376:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 318              		.loc 1 376 0
 319 01e8 204B     		ldr	r3, .L22+8
 320 01ea FF22     		movs	r2, #255
 321 01ec 1A70     		strb	r2, [r3]
 379:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 322              		.loc 1 379 0
 323 01ee 1D4B     		ldr	r3, .L22
 324 01f0 0022     		movs	r2, #0
 325 01f2 1A70     		strb	r2, [r3]
 382:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 326              		.loc 1 382 0
 327 01f4 214B     		ldr	r3, .L22+24
 328 01f6 1B78     		ldrb	r3, [r3]
 329 01f8 DBB2     		uxtb	r3, r3
 330 01fa 23F01003 		bic	r3, r3, #16
 331 01fe DAB2     		uxtb	r2, r3
 332 0200 1E4B     		ldr	r3, .L22+24
 333 0202 1A70     		strb	r2, [r3]
 385:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 334              		.loc 1 385 0
 335 0204 1E4B     		ldr	r3, .L22+28
 336 0206 0022     		movs	r2, #0
 337 0208 1A70     		strb	r2, [r3]
 338              		.loc 1 388 0
 339 020a 0CE0     		b	.L12
 340              	.L6:
 389:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 390:.\Generated_Source\PSoC5/EzI2C_INT.c ****             /* Second Device Address */
 391:.\Generated_Source\PSoC5/EzI2C_INT.c ****             #if (EzI2C_ADDRESSES == EzI2C_TWO_ADDRESSES)
 392:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 393:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 case EzI2C_SM_DEV2_WR_ADDR:
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 14


 394:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 395:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* If 8-bit interface, Advance to WR_Data, else to ADDR2 */
 396:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     #if (EzI2C_SUBADDR_WIDTH == EzI2C_SUBADDR_8BIT)
 397:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 398:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         tmp8 = EzI2C_DATA_REG;
 399:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         if (tmp8 < EzI2C_bufSizeS2)
 400:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         {
 401:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* ACK and ready to receive address */
 402:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_CSR_REG = EzI2C_CSR_ACK;
 403:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 404:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* Set offset to new value */
 405:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_rwOffsetS2 = tmp8;
 406:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 407:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* Reset index to offset value */
 408:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_rwIndexS2 = tmp8;
 409:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 410:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* Prepare for write transaction */
 411:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_curState = EzI2C_SM_DEV2_WR_DATA;
 412:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         }
 413:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         else    /* Out of range, NAK data and don't set offset */
 414:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         {
 415:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* NAK master */
 416:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_CSR_REG = EzI2C_CSR_NAK;
 417:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         }
 418:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     #else
 419:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Save LSB of address */
 420:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         tmp16 = EzI2C_DATA_REG;
 421:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 422:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* ACK and ready to receive address */
 423:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_CSR_REG = EzI2C_CSR_ACK;
 424:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 425:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Prepare to get LSB of address */
 426:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_curState = EzI2C_SM_DEV2_WR_ADDR_LSB;
 427:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     #endif  /* (EzI2C_SUBADDR_WIDTH == EzI2C_SUBADDR_8BIT) */
 428:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 429:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 break;  /* EzI2C_SM_DEV2_WR_ADDR */
 430:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 431:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 #if (EzI2C_SUBADDR_WIDTH == EzI2C_SUBADDR_16BIT)
 432:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 433:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Only used with 16-bit interface */
 434:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     case EzI2C_SM_DEV2_WR_ADDR_LSB:
 435:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Create offset */
 436:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         tmp16 = (uint16) (tmp16 << 8u) | EzI2C_DATA_REG;
 437:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         if (tmp16 < EzI2C_bufSizeS2)
 438:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         {
 439:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* ACK and ready to receive address */
 440:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_CSR_REG = EzI2C_CSR_ACK;
 441:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 442:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* Set offset to new value */
 443:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_rwOffsetS2 = tmp16;
 444:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 445:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* Reset index to offset value */
 446:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_rwIndexS2 = tmp16;
 447:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 448:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* Prepare for write transaction */
 449:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_curState = EzI2C_SM_DEV2_WR_DATA;
 450:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         }
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 15


 451:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         else    /* Out of range, NAK data and don't set offset */
 452:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         {
 453:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* NAK master */
 454:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_CSR_REG = EzI2C_CSR_NAK;
 455:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         }
 456:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         break; /* EzI2C_SM_DEV2_WR_ADDR_LSB */
 457:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 458:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 #endif   /* (EzI2C_SUBADDR_WIDTH == EzI2C_SUBADDR_16BIT) */
 459:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 460:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 461:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Data written from master to slave. */
 462:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 case EzI2C_SM_DEV2_WR_DATA:
 463:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 464:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Check for valid range */
 465:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     if (EzI2C_rwIndexS2 < EzI2C_wrProtectS2)
 466:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     {
 467:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Get data, to ACK quickly */
 468:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         tmp8 = EzI2C_DATA_REG;
 469:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 470:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* ACK and ready to receive sub address */
 471:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_CSR_REG = EzI2C_CSR_ACK;
 472:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 473:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Write data to array */
 474:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_dataPtrS2[EzI2C_rwIndexS2] = tmp8;
 475:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 476:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* Inc pointer */
 477:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         ++EzI2C_rwIndexS2;
 478:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     }
 479:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     else
 480:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     {
 481:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         /* NAK cause beyond write area */
 482:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         EzI2C_CSR_REG = EzI2C_CSR_NAK;
 483:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     }
 484:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     break;  /* EzI2C_SM_DEV2_WR_DATA */
 485:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 486:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     /* Data read by master from slave */
 487:.\Generated_Source\PSoC5/EzI2C_INT.c ****                     case EzI2C_SM_DEV2_RD_DATA:
 488:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 489:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         if ((tmpCsr & EzI2C_CSR_LRB) == EzI2C_CSR_LRB_ACK)
 490:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         {   /* ACKed */
 491:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* Check for valid range */
 492:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             if (EzI2C_rwIndexS2 < EzI2C_bufSizeS2)
 493:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             {   /* Check ACK/NAK */
 494:.\Generated_Source\PSoC5/EzI2C_INT.c ****                                 /* Get data from array */
 495:.\Generated_Source\PSoC5/EzI2C_INT.c ****                                 EzI2C_DATA_REG = EzI2C_dataPtrS2[EzI2C_rwIndexS2];
 496:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 497:.\Generated_Source\PSoC5/EzI2C_INT.c ****                                 /* Send Data */
 498:.\Generated_Source\PSoC5/EzI2C_INT.c ****                                 EzI2C_CSR_REG = EzI2C_CSR_TRANSMIT;
 499:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 500:.\Generated_Source\PSoC5/EzI2C_INT.c ****                                 /* Increment pointer */
 501:.\Generated_Source\PSoC5/EzI2C_INT.c ****                                 EzI2C_rwIndexS2++;
 502:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             }
 503:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             else    /* Not valid range */
 504:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             {
 505:.\Generated_Source\PSoC5/EzI2C_INT.c ****                                 /* Out of range send FFs */
 506:.\Generated_Source\PSoC5/EzI2C_INT.c ****                                 EzI2C_DATA_REG = EzI2C_DUMMY_DATA;
 507:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 16


 508:.\Generated_Source\PSoC5/EzI2C_INT.c ****                                 /* Send Data */
 509:.\Generated_Source\PSoC5/EzI2C_INT.c ****                                 EzI2C_CSR_REG = EzI2C_CSR_TRANSMIT;
 510:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             }
 511:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         }
 512:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         else    /* NAKed */
 513:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         {
 514:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* Out of range send FFs */
 515:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_DATA_REG = EzI2C_DUMMY_DATA;
 516:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 517:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* Send Data */
 518:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_CSR_REG = EzI2C_CSR_TRANSMIT;
 519:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 520:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* Clear busy status */
 521:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_curStatus &= ((uint8) ~EzI2C_STATUS_BUSY);
 522:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 523:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             /* Error or Stop, reset state */
 524:.\Generated_Source\PSoC5/EzI2C_INT.c ****                             EzI2C_curState = EzI2C_SM_IDLE;
 525:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         }   /* End if ACK/NAK */
 526:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 527:.\Generated_Source\PSoC5/EzI2C_INT.c ****                         break;  /* EzI2C_SM_DEV2_RD_DATA */
 528:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 529:.\Generated_Source\PSoC5/EzI2C_INT.c ****             #endif  /* (EzI2C_ADDRESSES == EzI2C_TWO_ADDRESSES) */
 530:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 531:.\Generated_Source\PSoC5/EzI2C_INT.c ****             default:
 532:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Invalid state, reset state to idle */
 533:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_curState = EzI2C_SM_IDLE;
 341              		.loc 1 533 0
 342 020c 1C4B     		ldr	r3, .L22+28
 343 020e 0022     		movs	r2, #0
 344 0210 1A70     		strb	r2, [r3]
 534:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 535:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Reset offsets and index */
 536:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_rwOffsetS1 = 0u;
 345              		.loc 1 536 0
 346 0212 184B     		ldr	r3, .L22+16
 347 0214 0022     		movs	r2, #0
 348 0216 1A80     		strh	r2, [r3]	@ movhi
 537:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_rwIndexS1  = 0u;
 349              		.loc 1 537 0
 350 0218 174B     		ldr	r3, .L22+20
 351 021a 0022     		movs	r2, #0
 352 021c 1A80     		strh	r2, [r3]	@ movhi
 538:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 539:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 /* Dummy NAK to release bus */
 540:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 EzI2C_CSR_REG = EzI2C_CSR_NAK;
 353              		.loc 1 540 0
 354 021e 114B     		ldr	r3, .L22
 355 0220 0022     		movs	r2, #0
 356 0222 1A70     		strb	r2, [r3]
 541:.\Generated_Source\PSoC5/EzI2C_INT.c ****                 break;
 357              		.loc 1 541 0
 358 0224 00BF     		nop
 359              	.L12:
 360              	.L5:
 542:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 543:.\Generated_Source\PSoC5/EzI2C_INT.c ****         }  /* End switch/case EzI2C_curState */
 544:.\Generated_Source\PSoC5/EzI2C_INT.c ****     }
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 17


 545:.\Generated_Source\PSoC5/EzI2C_INT.c ****     else
 546:.\Generated_Source\PSoC5/EzI2C_INT.c ****     {
 547:.\Generated_Source\PSoC5/EzI2C_INT.c ****         /* Intentional blank line */
 548:.\Generated_Source\PSoC5/EzI2C_INT.c ****     }
 549:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 550:.\Generated_Source\PSoC5/EzI2C_INT.c ****     /* Check if Stop was detected */
 551:.\Generated_Source\PSoC5/EzI2C_INT.c ****     if (EzI2C_IS_BIT_SET(EzI2C_CSR_REG, EzI2C_CSR_STOP_STATUS))
 361              		.loc 1 551 0
 362 0226 0F4B     		ldr	r3, .L22
 363 0228 1B78     		ldrb	r3, [r3]
 364 022a DBB2     		uxtb	r3, r3
 365 022c 03F02003 		and	r3, r3, #32
 366 0230 002B     		cmp	r3, #0
 367 0232 12D0     		beq	.L1
 552:.\Generated_Source\PSoC5/EzI2C_INT.c ****     {
 553:.\Generated_Source\PSoC5/EzI2C_INT.c ****         /* Clear Busy flag */
 554:.\Generated_Source\PSoC5/EzI2C_INT.c ****         EzI2C_curStatus &= ((uint8) ~EzI2C_STATUS_BUSY);
 368              		.loc 1 554 0
 369 0234 114B     		ldr	r3, .L22+24
 370 0236 1B78     		ldrb	r3, [r3]
 371 0238 DBB2     		uxtb	r3, r3
 372 023a 23F01003 		bic	r3, r3, #16
 373 023e DAB2     		uxtb	r2, r3
 374 0240 0E4B     		ldr	r3, .L22+24
 375 0242 1A70     		strb	r2, [r3]
 555:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 556:.\Generated_Source\PSoC5/EzI2C_INT.c ****         /* error or stop - reset state */
 557:.\Generated_Source\PSoC5/EzI2C_INT.c ****         EzI2C_curState = EzI2C_SM_IDLE;
 376              		.loc 1 557 0
 377 0244 0E4B     		ldr	r3, .L22+28
 378 0246 0022     		movs	r2, #0
 379 0248 1A70     		strb	r2, [r3]
 558:.\Generated_Source\PSoC5/EzI2C_INT.c **** 
 559:.\Generated_Source\PSoC5/EzI2C_INT.c ****         /* Disable interrupt on Stop */
 560:.\Generated_Source\PSoC5/EzI2C_INT.c ****         EzI2C_CFG_REG &= ((uint8) ~EzI2C_CFG_STOP_IE);
 380              		.loc 1 560 0
 381 024a 0E4A     		ldr	r2, .L22+32
 382 024c 0D4B     		ldr	r3, .L22+32
 383 024e 1B78     		ldrb	r3, [r3]
 384 0250 DBB2     		uxtb	r3, r3
 385 0252 23F01003 		bic	r3, r3, #16
 386 0256 DBB2     		uxtb	r3, r3
 387 0258 1370     		strb	r3, [r2]
 388              	.L1:
 561:.\Generated_Source\PSoC5/EzI2C_INT.c ****     }
 562:.\Generated_Source\PSoC5/EzI2C_INT.c **** #ifdef EzI2C_ISR_EXIT_CALLBACK
 563:.\Generated_Source\PSoC5/EzI2C_INT.c ****     EzI2C_ISR_ExitCallback();
 564:.\Generated_Source\PSoC5/EzI2C_INT.c **** #endif /* EzI2C_ISR_EXIT_CALLBACK */    
 565:.\Generated_Source\PSoC5/EzI2C_INT.c **** }
 389              		.loc 1 565 0
 390 025a BD46     		mov	sp, r7
 391              		.cfi_def_cfa_register 13
 392              		@ sp needed
 393 025c 5DF8047B 		ldr	r7, [sp], #4
 394              		.cfi_restore 7
 395              		.cfi_def_cfa_offset 0
 396 0260 7047     		bx	lr
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 18


 397              	.L23:
 398 0262 00BF     		.align	2
 399              	.L22:
 400 0264 D7490040 		.word	1073760727
 401 0268 00000000 		.word	tmpCsr.4850
 402 026c D8490040 		.word	1073760728
 403 0270 00000000 		.word	EzI2C_dataPtrS1
 404 0274 00000000 		.word	EzI2C_rwOffsetS1
 405 0278 00000000 		.word	EzI2C_rwIndexS1
 406 027c 00000000 		.word	EzI2C_curStatus
 407 0280 00000000 		.word	EzI2C_curState
 408 0284 D6490040 		.word	1073760726
 409 0288 02000000 		.word	tmp16.4851
 410 028c 00000000 		.word	EzI2C_bufSizeS1
 411 0290 00000000 		.word	EzI2C_wrProtectS1
 412 0294 04000000 		.word	tmp8.4849
 413              		.cfi_endproc
 414              	.LFE0:
 415              		.size	EzI2C_ISR, .-EzI2C_ISR
 416              		.bss
 417              	tmpCsr.4850:
 418 0000 00       		.space	1
 419 0001 00       		.align	1
 420              	tmp16.4851:
 421 0002 0000     		.space	2
 422              	tmp8.4849:
 423 0004 00       		.space	1
 424 0005 00       		.text
 425              	.Letext0:
 426              		.file 2 ".\\Generated_Source\\PSoC5\\cytypes.h"
 427              		.file 3 ".\\Generated_Source\\PSoC5\\EzI2C_PVT.h"
 428              		.section	.debug_info,"",%progbits
 429              	.Ldebug_info0:
 430 0000 4E010000 		.4byte	0x14e
 431 0004 0400     		.2byte	0x4
 432 0006 00000000 		.4byte	.Ldebug_abbrev0
 433 000a 04       		.byte	0x4
 434 000b 01       		.uleb128 0x1
 435 000c F8000000 		.4byte	.LASF26
 436 0010 01       		.byte	0x1
 437 0011 1D000000 		.4byte	.LASF27
 438 0015 5C000000 		.4byte	.LASF28
 439 0019 00000000 		.4byte	.Ldebug_ranges0+0
 440 001d 00000000 		.4byte	0
 441 0021 00000000 		.4byte	.Ldebug_line0
 442 0025 02       		.uleb128 0x2
 443 0026 01       		.byte	0x1
 444 0027 06       		.byte	0x6
 445 0028 2A020000 		.4byte	.LASF0
 446 002c 02       		.uleb128 0x2
 447 002d 01       		.byte	0x1
 448 002e 08       		.byte	0x8
 449 002f BE000000 		.4byte	.LASF1
 450 0033 02       		.uleb128 0x2
 451 0034 02       		.byte	0x2
 452 0035 05       		.byte	0x5
 453 0036 17020000 		.4byte	.LASF2
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 19


 454 003a 02       		.uleb128 0x2
 455 003b 02       		.byte	0x2
 456 003c 07       		.byte	0x7
 457 003d 36020000 		.4byte	.LASF3
 458 0041 02       		.uleb128 0x2
 459 0042 04       		.byte	0x4
 460 0043 05       		.byte	0x5
 461 0044 21020000 		.4byte	.LASF4
 462 0048 02       		.uleb128 0x2
 463 0049 04       		.byte	0x4
 464 004a 07       		.byte	0x7
 465 004b E0000000 		.4byte	.LASF5
 466 004f 02       		.uleb128 0x2
 467 0050 08       		.byte	0x8
 468 0051 05       		.byte	0x5
 469 0052 E2010000 		.4byte	.LASF6
 470 0056 02       		.uleb128 0x2
 471 0057 08       		.byte	0x8
 472 0058 07       		.byte	0x7
 473 0059 C2010000 		.4byte	.LASF7
 474 005d 03       		.uleb128 0x3
 475 005e 04       		.byte	0x4
 476 005f 05       		.byte	0x5
 477 0060 696E7400 		.ascii	"int\000"
 478 0064 02       		.uleb128 0x2
 479 0065 04       		.byte	0x4
 480 0066 07       		.byte	0x7
 481 0067 B5010000 		.4byte	.LASF8
 482 006b 04       		.uleb128 0x4
 483 006c F2000000 		.4byte	.LASF9
 484 0070 02       		.byte	0x2
 485 0071 3801     		.2byte	0x138
 486 0073 2C000000 		.4byte	0x2c
 487 0077 04       		.uleb128 0x4
 488 0078 9E010000 		.4byte	.LASF10
 489 007c 02       		.byte	0x2
 490 007d 3901     		.2byte	0x139
 491 007f 3A000000 		.4byte	0x3a
 492 0083 02       		.uleb128 0x2
 493 0084 04       		.byte	0x4
 494 0085 04       		.byte	0x4
 495 0086 B3000000 		.4byte	.LASF11
 496 008a 02       		.uleb128 0x2
 497 008b 08       		.byte	0x8
 498 008c 04       		.byte	0x4
 499 008d 86010000 		.4byte	.LASF12
 500 0091 02       		.uleb128 0x2
 501 0092 01       		.byte	0x1
 502 0093 08       		.byte	0x8
 503 0094 02020000 		.4byte	.LASF13
 504 0098 04       		.uleb128 0x4
 505 0099 DB000000 		.4byte	.LASF14
 506 009d 02       		.byte	0x2
 507 009e E201     		.2byte	0x1e2
 508 00a0 A4000000 		.4byte	0xa4
 509 00a4 05       		.uleb128 0x5
 510 00a5 6B000000 		.4byte	0x6b
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 20


 511 00a9 05       		.uleb128 0x5
 512 00aa 77000000 		.4byte	0x77
 513 00ae 02       		.uleb128 0x2
 514 00af 04       		.byte	0x4
 515 00b0 07       		.byte	0x7
 516 00b1 D9010000 		.4byte	.LASF15
 517 00b5 06       		.uleb128 0x6
 518 00b6 42000000 		.4byte	.LASF29
 519 00ba 01       		.byte	0x1
 520 00bb 57       		.byte	0x57
 521 00bc 00000000 		.4byte	.LFB0
 522 00c0 98020000 		.4byte	.LFE0-.LFB0
 523 00c4 01       		.uleb128 0x1
 524 00c5 9C       		.byte	0x9c
 525 00c6 FE000000 		.4byte	0xfe
 526 00ca 07       		.uleb128 0x7
 527 00cb B9000000 		.4byte	.LASF16
 528 00cf 01       		.byte	0x1
 529 00d0 59       		.byte	0x59
 530 00d1 6B000000 		.4byte	0x6b
 531 00d5 05       		.uleb128 0x5
 532 00d6 03       		.byte	0x3
 533 00d7 04000000 		.4byte	tmp8.4849
 534 00db 07       		.uleb128 0x7
 535 00dc 00000000 		.4byte	.LASF17
 536 00e0 01       		.byte	0x1
 537 00e1 5A       		.byte	0x5a
 538 00e2 6B000000 		.4byte	0x6b
 539 00e6 05       		.uleb128 0x5
 540 00e7 03       		.byte	0x3
 541 00e8 00000000 		.4byte	tmpCsr.4850
 542 00ec 07       		.uleb128 0x7
 543 00ed 17000000 		.4byte	.LASF18
 544 00f1 01       		.byte	0x1
 545 00f2 5D       		.byte	0x5d
 546 00f3 77000000 		.4byte	0x77
 547 00f7 05       		.uleb128 0x5
 548 00f8 03       		.byte	0x3
 549 00f9 02000000 		.4byte	tmp16.4851
 550 00fd 00       		.byte	0
 551 00fe 08       		.uleb128 0x8
 552 00ff 4C000000 		.4byte	.LASF19
 553 0103 03       		.byte	0x3
 554 0104 1D       		.byte	0x1d
 555 0105 A4000000 		.4byte	0xa4
 556 0109 08       		.uleb128 0x8
 557 010a CC000000 		.4byte	.LASF20
 558 010e 03       		.byte	0x3
 559 010f 1E       		.byte	0x1e
 560 0110 A4000000 		.4byte	0xa4
 561 0114 08       		.uleb128 0x8
 562 0115 07000000 		.4byte	.LASF21
 563 0119 03       		.byte	0x3
 564 011a 21       		.byte	0x21
 565 011b 1F010000 		.4byte	0x11f
 566 011f 09       		.uleb128 0x9
 567 0120 04       		.byte	0x4
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 21


 568 0121 A4000000 		.4byte	0xa4
 569 0125 08       		.uleb128 0x8
 570 0126 07020000 		.4byte	.LASF22
 571 012a 03       		.byte	0x3
 572 012b 22       		.byte	0x22
 573 012c A9000000 		.4byte	0xa9
 574 0130 08       		.uleb128 0x8
 575 0131 F0010000 		.4byte	.LASF23
 576 0135 03       		.byte	0x3
 577 0136 23       		.byte	0x23
 578 0137 A9000000 		.4byte	0xa9
 579 013b 08       		.uleb128 0x8
 580 013c 8D010000 		.4byte	.LASF24
 581 0140 03       		.byte	0x3
 582 0141 24       		.byte	0x24
 583 0142 A9000000 		.4byte	0xa9
 584 0146 08       		.uleb128 0x8
 585 0147 A5010000 		.4byte	.LASF25
 586 014b 03       		.byte	0x3
 587 014c 25       		.byte	0x25
 588 014d A9000000 		.4byte	0xa9
 589 0151 00       		.byte	0
 590              		.section	.debug_abbrev,"",%progbits
 591              	.Ldebug_abbrev0:
 592 0000 01       		.uleb128 0x1
 593 0001 11       		.uleb128 0x11
 594 0002 01       		.byte	0x1
 595 0003 25       		.uleb128 0x25
 596 0004 0E       		.uleb128 0xe
 597 0005 13       		.uleb128 0x13
 598 0006 0B       		.uleb128 0xb
 599 0007 03       		.uleb128 0x3
 600 0008 0E       		.uleb128 0xe
 601 0009 1B       		.uleb128 0x1b
 602 000a 0E       		.uleb128 0xe
 603 000b 55       		.uleb128 0x55
 604 000c 17       		.uleb128 0x17
 605 000d 11       		.uleb128 0x11
 606 000e 01       		.uleb128 0x1
 607 000f 10       		.uleb128 0x10
 608 0010 17       		.uleb128 0x17
 609 0011 00       		.byte	0
 610 0012 00       		.byte	0
 611 0013 02       		.uleb128 0x2
 612 0014 24       		.uleb128 0x24
 613 0015 00       		.byte	0
 614 0016 0B       		.uleb128 0xb
 615 0017 0B       		.uleb128 0xb
 616 0018 3E       		.uleb128 0x3e
 617 0019 0B       		.uleb128 0xb
 618 001a 03       		.uleb128 0x3
 619 001b 0E       		.uleb128 0xe
 620 001c 00       		.byte	0
 621 001d 00       		.byte	0
 622 001e 03       		.uleb128 0x3
 623 001f 24       		.uleb128 0x24
 624 0020 00       		.byte	0
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 22


 625 0021 0B       		.uleb128 0xb
 626 0022 0B       		.uleb128 0xb
 627 0023 3E       		.uleb128 0x3e
 628 0024 0B       		.uleb128 0xb
 629 0025 03       		.uleb128 0x3
 630 0026 08       		.uleb128 0x8
 631 0027 00       		.byte	0
 632 0028 00       		.byte	0
 633 0029 04       		.uleb128 0x4
 634 002a 16       		.uleb128 0x16
 635 002b 00       		.byte	0
 636 002c 03       		.uleb128 0x3
 637 002d 0E       		.uleb128 0xe
 638 002e 3A       		.uleb128 0x3a
 639 002f 0B       		.uleb128 0xb
 640 0030 3B       		.uleb128 0x3b
 641 0031 05       		.uleb128 0x5
 642 0032 49       		.uleb128 0x49
 643 0033 13       		.uleb128 0x13
 644 0034 00       		.byte	0
 645 0035 00       		.byte	0
 646 0036 05       		.uleb128 0x5
 647 0037 35       		.uleb128 0x35
 648 0038 00       		.byte	0
 649 0039 49       		.uleb128 0x49
 650 003a 13       		.uleb128 0x13
 651 003b 00       		.byte	0
 652 003c 00       		.byte	0
 653 003d 06       		.uleb128 0x6
 654 003e 2E       		.uleb128 0x2e
 655 003f 01       		.byte	0x1
 656 0040 3F       		.uleb128 0x3f
 657 0041 19       		.uleb128 0x19
 658 0042 03       		.uleb128 0x3
 659 0043 0E       		.uleb128 0xe
 660 0044 3A       		.uleb128 0x3a
 661 0045 0B       		.uleb128 0xb
 662 0046 3B       		.uleb128 0x3b
 663 0047 0B       		.uleb128 0xb
 664 0048 27       		.uleb128 0x27
 665 0049 19       		.uleb128 0x19
 666 004a 11       		.uleb128 0x11
 667 004b 01       		.uleb128 0x1
 668 004c 12       		.uleb128 0x12
 669 004d 06       		.uleb128 0x6
 670 004e 40       		.uleb128 0x40
 671 004f 18       		.uleb128 0x18
 672 0050 9742     		.uleb128 0x2117
 673 0052 19       		.uleb128 0x19
 674 0053 01       		.uleb128 0x1
 675 0054 13       		.uleb128 0x13
 676 0055 00       		.byte	0
 677 0056 00       		.byte	0
 678 0057 07       		.uleb128 0x7
 679 0058 34       		.uleb128 0x34
 680 0059 00       		.byte	0
 681 005a 03       		.uleb128 0x3
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 23


 682 005b 0E       		.uleb128 0xe
 683 005c 3A       		.uleb128 0x3a
 684 005d 0B       		.uleb128 0xb
 685 005e 3B       		.uleb128 0x3b
 686 005f 0B       		.uleb128 0xb
 687 0060 49       		.uleb128 0x49
 688 0061 13       		.uleb128 0x13
 689 0062 02       		.uleb128 0x2
 690 0063 18       		.uleb128 0x18
 691 0064 00       		.byte	0
 692 0065 00       		.byte	0
 693 0066 08       		.uleb128 0x8
 694 0067 34       		.uleb128 0x34
 695 0068 00       		.byte	0
 696 0069 03       		.uleb128 0x3
 697 006a 0E       		.uleb128 0xe
 698 006b 3A       		.uleb128 0x3a
 699 006c 0B       		.uleb128 0xb
 700 006d 3B       		.uleb128 0x3b
 701 006e 0B       		.uleb128 0xb
 702 006f 49       		.uleb128 0x49
 703 0070 13       		.uleb128 0x13
 704 0071 3F       		.uleb128 0x3f
 705 0072 19       		.uleb128 0x19
 706 0073 3C       		.uleb128 0x3c
 707 0074 19       		.uleb128 0x19
 708 0075 00       		.byte	0
 709 0076 00       		.byte	0
 710 0077 09       		.uleb128 0x9
 711 0078 0F       		.uleb128 0xf
 712 0079 00       		.byte	0
 713 007a 0B       		.uleb128 0xb
 714 007b 0B       		.uleb128 0xb
 715 007c 49       		.uleb128 0x49
 716 007d 13       		.uleb128 0x13
 717 007e 00       		.byte	0
 718 007f 00       		.byte	0
 719 0080 00       		.byte	0
 720              		.section	.debug_aranges,"",%progbits
 721 0000 1C000000 		.4byte	0x1c
 722 0004 0200     		.2byte	0x2
 723 0006 00000000 		.4byte	.Ldebug_info0
 724 000a 04       		.byte	0x4
 725 000b 00       		.byte	0
 726 000c 0000     		.2byte	0
 727 000e 0000     		.2byte	0
 728 0010 00000000 		.4byte	.LFB0
 729 0014 98020000 		.4byte	.LFE0-.LFB0
 730 0018 00000000 		.4byte	0
 731 001c 00000000 		.4byte	0
 732              		.section	.debug_ranges,"",%progbits
 733              	.Ldebug_ranges0:
 734 0000 00000000 		.4byte	.LFB0
 735 0004 98020000 		.4byte	.LFE0
 736 0008 00000000 		.4byte	0
 737 000c 00000000 		.4byte	0
 738              		.section	.debug_line,"",%progbits
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 24


 739              	.Ldebug_line0:
 740 0000 C0000000 		.section	.debug_str,"MS",%progbits,1
 740      02005700 
 740      00000201 
 740      FB0E0D00 
 740      01010101 
 741              	.LASF17:
 742 0000 746D7043 		.ascii	"tmpCsr\000"
 742      737200
 743              	.LASF21:
 744 0007 457A4932 		.ascii	"EzI2C_dataPtrS1\000"
 744      435F6461 
 744      74615074 
 744      72533100 
 745              	.LASF18:
 746 0017 746D7031 		.ascii	"tmp16\000"
 746      3600
 747              	.LASF27:
 748 001d 2E5C4765 		.ascii	".\\Generated_Source\\PSoC5\\EzI2C_INT.c\000"
 748      6E657261 
 748      7465645F 
 748      536F7572 
 748      63655C50 
 749              	.LASF29:
 750 0042 457A4932 		.ascii	"EzI2C_ISR\000"
 750      435F4953 
 750      5200
 751              	.LASF19:
 752 004c 457A4932 		.ascii	"EzI2C_curStatus\000"
 752      435F6375 
 752      72537461 
 752      74757300 
 753              	.LASF28:
 754 005c 443A5C55 		.ascii	"D:\\Utilisateurs\\user\\Documents\\PSoC Creator\\Wo"
 754      74696C69 
 754      73617465 
 754      7572735C 
 754      75736572 
 755 008a 726B7370 		.ascii	"rkspace02\\CapSense_CSD_WithTuner01.cydsn\000"
 755      61636530 
 755      325C4361 
 755      7053656E 
 755      73655F43 
 756              	.LASF11:
 757 00b3 666C6F61 		.ascii	"float\000"
 757      7400
 758              	.LASF16:
 759 00b9 746D7038 		.ascii	"tmp8\000"
 759      00
 760              	.LASF1:
 761 00be 756E7369 		.ascii	"unsigned char\000"
 761      676E6564 
 761      20636861 
 761      7200
 762              	.LASF20:
 763 00cc 457A4932 		.ascii	"EzI2C_curState\000"
 763      435F6375 
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 25


 763      72537461 
 763      746500
 764              	.LASF14:
 765 00db 72656738 		.ascii	"reg8\000"
 765      00
 766              	.LASF5:
 767 00e0 6C6F6E67 		.ascii	"long unsigned int\000"
 767      20756E73 
 767      69676E65 
 767      6420696E 
 767      7400
 768              	.LASF9:
 769 00f2 75696E74 		.ascii	"uint8\000"
 769      3800
 770              	.LASF26:
 771 00f8 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 771      4320342E 
 771      392E3320 
 771      32303135 
 771      30333033 
 772 012b 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m3 -mthumb -g -O"
 772      20726576 
 772      6973696F 
 772      6E203232 
 772      31323230 
 773 015e 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 773      66756E63 
 773      74696F6E 
 773      2D736563 
 773      74696F6E 
 774              	.LASF12:
 775 0186 646F7562 		.ascii	"double\000"
 775      6C6500
 776              	.LASF24:
 777 018d 457A4932 		.ascii	"EzI2C_rwOffsetS1\000"
 777      435F7277 
 777      4F666673 
 777      65745331 
 777      00
 778              	.LASF10:
 779 019e 75696E74 		.ascii	"uint16\000"
 779      313600
 780              	.LASF25:
 781 01a5 457A4932 		.ascii	"EzI2C_rwIndexS1\000"
 781      435F7277 
 781      496E6465 
 781      78533100 
 782              	.LASF8:
 783 01b5 756E7369 		.ascii	"unsigned int\000"
 783      676E6564 
 783      20696E74 
 783      00
 784              	.LASF7:
 785 01c2 6C6F6E67 		.ascii	"long long unsigned int\000"
 785      206C6F6E 
 785      6720756E 
 785      7369676E 
ARM GAS  C:\Users\user\AppData\Local\Temp\ccbiyZZr.s 			page 26


 785      65642069 
 786              	.LASF15:
 787 01d9 73697A65 		.ascii	"sizetype\000"
 787      74797065 
 787      00
 788              	.LASF6:
 789 01e2 6C6F6E67 		.ascii	"long long int\000"
 789      206C6F6E 
 789      6720696E 
 789      7400
 790              	.LASF23:
 791 01f0 457A4932 		.ascii	"EzI2C_wrProtectS1\000"
 791      435F7772 
 791      50726F74 
 791      65637453 
 791      3100
 792              	.LASF13:
 793 0202 63686172 		.ascii	"char\000"
 793      00
 794              	.LASF22:
 795 0207 457A4932 		.ascii	"EzI2C_bufSizeS1\000"
 795      435F6275 
 795      6653697A 
 795      65533100 
 796              	.LASF2:
 797 0217 73686F72 		.ascii	"short int\000"
 797      7420696E 
 797      7400
 798              	.LASF4:
 799 0221 6C6F6E67 		.ascii	"long int\000"
 799      20696E74 
 799      00
 800              	.LASF0:
 801 022a 7369676E 		.ascii	"signed char\000"
 801      65642063 
 801      68617200 
 802              	.LASF3:
 803 0236 73686F72 		.ascii	"short unsigned int\000"
 803      7420756E 
 803      7369676E 
 803      65642069 
 803      6E7400
 804              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
